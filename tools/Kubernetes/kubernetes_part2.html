<html><h2><u><center>Kubernetes Part 2</center></u></h2>
<h4><pre>
<h3><u>Kubernetes Objects</u></h3> 
-> Kubernetes uses objects to represent the state of your cluster.
-> What containerized applications are running (and on which node).
-> The policies around how those applications behave, such as restart policies, upgrades and fault tolerance.
-> Once you create the object, the Kubernetes system will constantly work to ensure that object exist and maintains cluster's desired state.
-> Every Kubernetes object includes two nested fields that govern the object config, the object spec and the object status.
-> The spec, which we provide, describes your desired state for the object, the characteristics that you want the object to have.
-> The status describes the actual state of the object and is supplied and updated by the Kubernetes system.
-> All objects are identified by a unique name and UID.
-> It represents as JSON or YAML files.
-> You create these and then push them to the Kubernetes API with kubectl.
-> The basic Kubernetes objects include -
   1. POD
   2. Service
   3. Volume
   4. Namespace
   5. Replicasets
   6. Secrets
   7. ConfigMaps
   8. Deployments
   9. Jobs
   10. Daemonsets

<h3><u>Relationship between these Objects</u></h3>    
-> Pod manages containers
-> Replicaset manages pods
-> Services expose pod processes to the outside world
-> Configmaps and secrets helps you config pods.

<h3><u>State of the Object</u></h3> 
1. Replicas (2/2)
2. Image (Tomcat/ubuntu)
3. Name
4. Port
5. Volume
6. Startup command
7. Detached (default)

<h3><u>Kubernetes Objects Management</u></h3> 
-> The kubectl command line tool supports several different ways to create and manage Kubernetes object.
-> Management Technique - 
   - Imperative Commands (Operates On: Live Objects, Recommended Environment: Development Projects)
   - Declarative Object Configuration (Operates On: Individual files {JSON/YML}, Recommended Environment: Production)
-> Declarative is about describing what you are trying to achieve, without instructing how to do it.
-> Imperative, explicitly tells "how to accomplish it".

<h3><u>Fundamental of Pods</u></h3>
-> When a pod gets created, it is scheduled to run on a node in your cluster.
-> The pod remains on that node until the process is terminated, the pod object is deleted, the pod is evicted for lack of resources, or the node fails.
-> If a pod is scheduled to a node that fails, or if the scheduling operation itself fails, the pod is deleted.
-> If a node dies, the pod scheduled to that node are scheduled for deletion after a time period.
-> A given pod (UID) is not "rescheduled" to a new node, instead it will be replaced by an identical Pod, with even the same name if desired, but with the new UID.
-> Volume in a POD will exists as long as that POD (with that UID) exist. If that POD is deleted for any reason, volume is also destroyed and created as new on new POD.
-> A controller can create and manage multiple pods, handling replication, roll-out and providing self-healing capabilities.

<h3><u>Setup of Kubernetes Cluster</u></h3>
1. All-in-one Single Node Installation
-> With all-in-one, all the master and worker components are installed on a single node.
-> This is very useful for learning, development and testing.
-> This type should not be used in production.
-> Minikube is one such example.

2. Single-Node etcd, single-Master and Multi-worker installation
-> In this setup, we have a single master node, which also runs a single-node etcd instance.
-> Multiple worker nodes are connected to the master node.

3. Single-Node etcd, Multi-Master and Multi-worker installation
-> In this setup, we have multiple master nodes, which works in an HA mode, but we have a single-node etcd instance.
-> Multiple worker nodes are connected to the master node.
</h4>
</pre></html>  