<html><h2><u><center>Architect</u></center>
<h4><pre>

1. Architect for testability
   - Systems that can’t readily be tested can’t readily be changed
   - In a system that is designed for testability, all jobs require less time
   - Patterns that can accelerate value flow:
     - Domain Driven Design (DDD)
     - Loose coupling and API-driven architecture 
     - Cloud-native architecture 
     - Microservices and containerization
     - Serverless architecture
     - Strangler pattern
	 
2. Separate deploy and release
   - Deploy to production environments frequently
   - Release functionality to end users on demand
   - Hide new functionality under feature toggles
   - Implement Enabler Epics, Capabilities, Features, and/or Stories to achieve separation
   
3. Decouple release elements
   - Different parts of the Solution may require different release strategies
   - Architect the Solution to enable elements to be released independently
   - Shift the strategies based on business demand   
   
4. Architect for operations
   - Take operational needs into account
   - Build telemetry and logging Capabilities into every application and into the Solution as a whole
   - Allow services to be downgraded or even removed in times of high loads or in response to incidents
   - Build Capabilities for fast recovery and for fix-forward
   
5. Threat modeling
   - Consider information security early when planning
   - Identify potential security threats and attack vectors
   - Architect to address security concerns
   - Ensure backlogs reflect important security requirements
</body>
</h4></pre>
</html>